
## 一、编码规范
- BigDecimal 判断是否正确使用 `compareTo`，而非 `equals`
- 是否避免使用魔法值，常量是否统一管理
- 日志规范：是否避免打印敏感信息；是否使用占位符避免字符串拼接
- 异常处理规范：是否使用自定义业务异常；是否添加必要上下文信息
---

## 二、数据访问与事务管理

### 1. 事务注解有效性检查
- **自调用问题**：同类内部方法调用是否导致 `@Transactional` 失效
- **异常被捕获**：事务方法中是否捕获异常且未继续抛出，导致事务未回滚
- **异常类型**：`rollbackFor` 是否正确配置（默认只回滚 `RuntimeException`）
- **方法可见性**：`@Transactional` 是否使用在非 `public` 方法上
- **代理问题**：类是否被 CGLIB/JDK 代理影响事务生效（特别是 `final` 类、`final` 方法）

### 2. 事务中的危险操作
- 是否在事务中执行 RPC/HTTP 调用、MQ 投递等外部操作
- 是否存在“大事务”，事务范围是否过大（如跨多个业务步骤）
- 是否在事务中使用阻塞操作（sleep、大循环等）导致锁时间过长

### 3. SQL 与性能
- 是否存在 SQL 注入风险（手写 SQL 拼接）
- 是否存在 N+1 查询问题
- 是否可能触发全表扫描（缺少索引、条件为空）
- 分页偏移量是否过大（如 `LIMIT offset, size` 且 offset > 5000）
- 批量插入/更新是否使用了批操作
- 查询是否正确使用索引字段（避免函数运算导致索引失效）

---

## 三、异步任务与定时任务

### 1. 批处理任务的正确性
- 根据状态扫描数据并更新状态时，是否存在漏扫数据问题
- 分页处理时分页参数是否正确更新
- 终止条件是否正确，避免死循环
- 是否增加锁（如分布式锁）避免任务重复执行

### 2. 线程池使用
- 是否使用了统一的线程池，而不是自行创建线程
- 线程池是否配置合理（核心线程数、队列大小、拒绝策略）    
- 异步任务的异常是否被正常捕获和记录

---

## 四、消息队列（MQ）

### 1. 消费幂等性
- 消费端是否具备幂等机制（锁、唯一索引、幂等表）
- 消息是否可能重复投递，代码是否处理重复场景
- 是否正确设置消息重试次数与 DLQ（死信队列）

### 2. 消息格式与兼容性
- 消息格式是否可扩展（字段新增是否兼容）
- 是否避免强校验导致老版本消息消费失败

---

## 五、远程调用与接口契约

### 1. 接口兼容性
- 协议字段是否兼容升级（如 thrift/protobuf 字段序号修改、字段类型变更）
- 新增字段是否允许老客户端不传
- 服务提供方与调用方版本是否存在兼容性风险

### 2. 超时与重试
- 是否正确配置超时时间
- 是否正确的重试策略，避免对方服务雪崩
- 是否避免幂等性缺失导致重试问题

---

## 六、并发与锁
- 关键业务代码是否添加分布式锁或数据库乐观锁
- 是否存在并发更新导致数据不一致的问题
- 乐观锁版本号是否正确维护
- 分布式锁是否设置过期时间避免死锁
- 是否避免将锁粒度设置过大

---

## 七、配置管理
- 是否存在硬编码配置项（应使用 `@Value` 或配置中心）
- 密钥等敏感信息是否采用配置中心+KMS 加密
- 是否区分不同环境配置（dev/staging/prod）
- 配置变更是否可动态刷新（如 Spring Cloud Config + @RefreshScope）

---

## 八、业务安全与数据权限
- 接口是否进行身份校验、权限校验
- 是否校验资源归属（水平越权/垂直越权）
- 上传文件大小、格式、URL 的白名单是否严格限制
- 是否对外暴露过多 debug 信息（如异常堆栈抛出）
